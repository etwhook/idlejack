#include<Windows.h>
#include<iostream>
#include<TlHelp32.h>
#pragma once

unsigned char shellcode[] = { 0xeb,0x27,0x5b,0x53,0x5f,0xb0,0x75,0xfc,0xae,0x75,0xfd,0x57,0x59,0x53,0x5e,
			0x8a,0x06,0x30,0x07,0x48,0xff,0xc7,0x48,0xff,0xc6,0x66,0x81,0x3f,0x82,0x54,
			0x74,0x07,0x80,0x3e,0x75,0x75,0xea,0xeb,0xe6,0xff,0xe1,0xe8,0xd4,0xff,0xff,
			0xff,0x14,0x75,0xe8,0x5c,0x95,0xf0,0xe4,0xeb,0xeb,0xeb,0xfc,0xc4,0x14,0x14,
			0x14,0x55,0x45,0x55,0x44,0x46,0x45,0x42,0x5c,0x25,0xc6,0x71,0x5c,0x9f,0x46,
			0x74,0x2a,0x5c,0x9f,0x46,0x0c,0x2a,0x5c,0x9f,0x46,0x34,0x2a,0x5c,0x9f,0x66,
			0x44,0x2a,0x5c,0x1b,0xa3,0x5e,0x5e,0x59,0x25,0xdd,0x5c,0x25,0xd4,0xb8,0x28,
			0x75,0x68,0x16,0x38,0x34,0x55,0xd5,0xdd,0x19,0x55,0x15,0xd5,0xf6,0xf9,0x46,
			0x55,0x45,0x2a,0x5c,0x9f,0x46,0x34,0x2a,0x9f,0x56,0x28,0x5c,0x15,0xc4,0x2a,
			0x9f,0x94,0x9c,0x14,0x14,0x14,0x5c,0x91,0xd4,0x60,0x7b,0x5c,0x15,0xc4,0x44,
			0x2a,0x9f,0x5c,0x0c,0x2a,0x50,0x9f,0x54,0x34,0x5d,0x15,0xc4,0xf7,0x48,0x5c,
			0xeb,0xdd,0x2a,0x55,0x9f,0x20,0x9c,0x5c,0x15,0xc2,0x59,0x25,0xdd,0x5c,0x25,
			0xd4,0xb8,0x55,0xd5,0xdd,0x19,0x55,0x15,0xd5,0x2c,0xf4,0x61,0xe5,0x2a,0x58,
			0x17,0x58,0x30,0x1c,0x51,0x2d,0xc5,0x61,0xc2,0x4c,0x2a,0x50,0x9f,0x54,0x30,
			0x5d,0x15,0xc4,0x72,0x2a,0x55,0x9f,0x18,0x5c,0x2a,0x50,0x9f,0x54,0x08,0x5d,
			0x15,0xc4,0x2a,0x55,0x9f,0x10,0x9c,0x5c,0x15,0xc4,0x55,0x4c,0x55,0x4c,0x4a,
			0x4d,0x4e,0x55,0x4c,0x55,0x4d,0x55,0x4e,0x5c,0x97,0xf8,0x34,0x55,0x46,0xeb,
			0xf4,0x4c,0x55,0x4d,0x4e,0x2a,0x5c,0x9f,0x06,0xfd,0x5d,0xeb,0xeb,0xeb,0x49,
			0x5d,0xd3,0xd5,0x14,0x14,0x14,0x14,0x2a,0x5c,0x99,0x81,0x0e,0x15,0x14,0x14,
			0x2a,0x58,0x99,0x91,0x3f,0x15,0x14,0x14,0x5c,0x25,0xdd,0x55,0xae,0x51,0x97,
			0x42,0x13,0xeb,0xc1,0xaf,0xf4,0x09,0x3e,0x1e,0x55,0xae,0xb2,0x81,0xa9,0x89,
			0xeb,0xc1,0x5c,0x97,0xd0,0x3c,0x28,0x12,0x68,0x1e,0x94,0xef,0xf4,0x61,0x11,
			0xaf,0x53,0x07,0x66,0x7b,0x7e,0x14,0x4d,0x55,0x9d,0xce,0xeb,0xc1,0x5c,0x75,
			0x77,0x7f,0x34,0x60,0x7c,0x71,0x34,0x44,0x78,0x75,0x7a,0x71,0x60,0x35,0x14,
			0x40,0x5c,0x51,0x34,0x53,0x5d,0x56,0x47,0x5b,0x5a,0x14,0x82,0x54 };

namespace debug {
	void info(const char* message) {
		printf("[*] %s\n", message);
	}
	void succ(const char* message) {
		printf("[+] %s\n", message);
	}
	void err(const char* message) {
		printf("[-] %s\n", message);
	}
}
namespace celestial {
	DWORD getRobloxPID() {
		PROCESSENTRY32 pe32;
		pe32.dwSize = sizeof(PROCESSENTRY32);
		auto snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
		Process32First(snapshot, &pe32);
		while (Process32Next(snapshot, &pe32)) {
			PWSTR name = (PWSTR)pe32.szExeFile;
			if (wcscmp(name, L"RobloxPlayerBeta.exe") == 0)
				return pe32.th32ProcessID;
		}
	}
	HANDLE getHijackableThread(DWORD robloxPID) {
		THREADENTRY32 t32;
		t32.dwSize = sizeof(THREADENTRY32);
		auto snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
		Thread32First(snapshot, &t32);

		while (Thread32Next(snapshot, &t32)) {
			DWORD threadID = t32.th32ThreadID;
			DWORD ownerID = t32.th32OwnerProcessID;
			if (robloxPID != ownerID)
				continue;
			HANDLE thread = OpenThread(THREAD_ALL_ACCESS, FALSE, threadID);
			if (thread == INVALID_HANDLE_VALUE || thread == NULL)
				continue;
			int threadPr = GetThreadPriority(thread);

			
			if (threadPr != THREAD_PRIORITY_IDLE) {
				CloseHandle(thread);
				continue;
			}
				
			printf("[!] Found Idle Thread With ID: %ld\n", threadID);
			return thread;

		}
	}
	PVOID allocateRemoteMemory(DWORD PID) {
		HANDLE hProc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PID);
		if (hProc == INVALID_HANDLE_VALUE || hProc == NULL) {
			return NULL;
		}
		SIZE_T szBuf = sizeof(shellcode);
		PVOID remBuf = VirtualAllocEx(hProc, NULL, szBuf, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
		if (remBuf == NULL) {
			return NULL;
		}
		SIZE_T writtenBytes = 0;
		bool writeSuc = WriteProcessMemory(hProc, remBuf, (LPCVOID)shellcode, szBuf, &writtenBytes);
		if (!writeSuc) {
			return NULL;
		}
		return remBuf;

	}
	bool setPriority(HANDLE thread) {
		return SetThreadPriority(thread, THREAD_PRIORITY_NORMAL);
	}
	DWORD hijackThread(HANDLE thread, PVOID* ripAddr) {
		bool susThr = SuspendThread(thread);
		printf("%d\n", susThr);
		CONTEXT thrContext;
		thrContext.ContextFlags = CONTEXT_FULL;
		bool gtc = GetThreadContext(thread, &thrContext);
		printf("%d\n", gtc);
		thrContext.Rip = (DWORD_PTR)(*ripAddr);
		bool stc = SetThreadContext(thread, &thrContext);
		printf("%d\n", stc);
		return ResumeThread(thread);
	}
	void cleanup(HANDLE thread) {
		CloseHandle(thread);
	}
}